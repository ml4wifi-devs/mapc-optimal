mapc_optimal
============

.. py:module:: mapc_optimal


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/mapc_optimal/constants/index
   /autoapi/mapc_optimal/main/index
   /autoapi/mapc_optimal/pricing/index
   /autoapi/mapc_optimal/solver/index
   /autoapi/mapc_optimal/utils/index


Classes
-------

.. autoapisummary::

   mapc_optimal.Solver


Functions
---------

.. autoapisummary::

   mapc_optimal.positions_to_path_loss


Package Contents
----------------

.. py:class:: Solver(stations, access_points, mcs_values = len(DATA_RATES), mcs_data_rates = DATA_RATES, min_snr = MIN_SNRS, max_tx_power = MAX_TX_POWER, min_tx_power = MIN_TX_POWER, noise_floor = NOISE_FLOOR, min_throughput = 0.0, opt_sum = False, max_iterations = 100, epsilon = 1e-05, solver = None)

   The solver class coordinating the overall process of finding the optimal solution.
   It initializes the solver, sets up the network configuration, and manages the iterations.
   The optimization problem can be formulated in two ways:
   - the total throughput of the network is maximized,
   - the worst throughput of each node is maximized.

   .. rubric:: Examples

   .. code-block:: python

      from mapc_optimal import Solver

      # Define your network
      # ...

      solver = Solver(stations, access_points)
      configurations, rate = solver(path_loss)

   .. note::
       The solver requires the path loss between each pair of nodes in the
       network. The reason for this is that the solver should be independent
       of the channel model used. Therefore, the path loss must be
       calculated beforehand. Note that if you do not require a specific
       channel model, you can use the provided function to calculate the
       path loss using the TGax channel model based on the positions of the
       nodes:


       .. code:: python

           import numpy as np
           from mapc_optimal import position_to_path_loss

           # Positions of the nodes as an array of `x` and `y` coordinates. `i`-th row represents the position
           # of the node with identifier `i` in the `stations` and `access_points` lists.
           pos = np.array([
             [x_0, y_0],
             [x_1, y_1],
             ...
             [x_n-1, y_n-1]
           ])

           # A matrix representing the walls in the environment (1 - wall, 0 - no wall between nodes `i` and `j`).
           walls = np.zeros((n, n))
           walls[i_0, j_0] = 1
           walls[i_1, j_1] = 1
           ...
           walls[i_m, j_m] = 1

           # n x n matrix representing the path loss between each pair of nodes.
           path_loss = position_to_path_loss(pos, walls)

   .. note::
       Identifiers of the stations and APs should be unique and
       cover the range from :math:`0` to :math:`n - 1` (where :math:`n` is the
       total number of nodes in the network).

   .. note::
       The performance of the solver can significantly depend on the underlying
       mixed-integer linear programming solver. The default one is PULP_CBC,
       which is a free and open-source solver provided by the PuLP library.
       However, we recommend using a better solver, such as CPLEX.

   :param stations: Lists of numbers representing the stations.
   :type stations: :class:`list`
   :param access_points: Lists of numbers representing the access points (APs) in the network.
   :type access_points: :class:`list`
   :param mcs_values: A number of MCS values available in the network. IEEE 802.11ax values are used by default.
   :type mcs_values: :class:`int`, *default* ``12``
   :param mcs_data_rates: A list of data rates corresponding to the MCS values (Mb/s) IEEE 802.11ax single stream with
                          20MHz bandwidth and 800 ns GI data rates by default.
   :type mcs_data_rates: :class:`NDArray`, *default* :class:`mapc_optimal.constants.DATA_RATES`
   :param min_snr: The minimum SNR required for a successful transmission (dB) for each MCS value. Empirically
                   determined in ns-3 simulations by default.
   :type min_snr: :class:`NDArray`, *default* :class:`mapc_optimal.constants.MIN_SNRS`
   :param max_tx_power: The maximum transmission power (dBm) available.
   :type max_tx_power: :class:`float`, *default* ``20.0``
   :param min_tx_power: The minimum transmission power (dBm) that can be used.
   :type min_tx_power: :class:`float`, *default* ``10.0``
   :param noise_floor: The level of noise in the environment (dBm).
   :type noise_floor: :class:`float`, *default* ``-93.97``
   :param min_throughput: The minimum throughput required for each node (Mb/s) while maximizing the total throughput.
   :type min_throughput: :class:`float`, *default* ``0.0``
   :param opt_sum: A boolean value indicating whether to maximize the sum of the throughput of all nodes in the network
                   (`True`) or the minimum throughput of all nodes in the network (`False`).
   :type opt_sum: :class:`bool`, *default* :obj:`False`
   :param max_iterations: The maximum number of iterations of the solver.
   :type max_iterations: :class:`int`, *default* ``100``
   :param epsilon: The minimum value of the pricing objective function to continue the iterations.
   :type epsilon: :class:`float`, *default* ``1e-5``
   :param solver: The solver used to solve the optimization problems.
   :type solver: :class:`pulp.LpSolver`, *default* :class:`pulp.PULP_CBC_CMD(msg=False)`


   .. py:attribute:: stations


   .. py:attribute:: access_points


   .. py:attribute:: mcs_values


   .. py:attribute:: mcs_data_rates
      :value: [8.6, 17.2, 25.8, 34.4, 51.6, 68.8, 77.4, 86.0, 103.2, 114.7, 129.0, 143.2]



   .. py:attribute:: min_sinr


   .. py:attribute:: max_tx_power


   .. py:attribute:: min_tx_power


   .. py:attribute:: noise_floor


   .. py:attribute:: min_throughput
      :value: 0.0



   .. py:attribute:: opt_sum
      :value: False



   .. py:attribute:: max_iterations
      :value: 100



   .. py:attribute:: epsilon
      :value: 1e-05



   .. py:attribute:: solver


   .. py:attribute:: main


   .. py:attribute:: pricing


   .. py:method:: __call__(path_loss, associations = None, return_objectives = False)

      Solves the MAPC C-SR problem given the path loss between each pair of nodes in the network.
      Returns the final configurations, the time shares, and the total throughput.

      :param path_loss: Matrix containing the path loss between each pair of nodes.
      :type path_loss: :class:`NDArray`
      :param associations: The dictionary of associations between APs and stations.
      :type associations: :class:`dict`
      :param return_objectives: Flag indicating whether to return the pricing objective values.
      :type return_objectives: :class:`bool`, *default* :obj:`False`

      :returns: **result** -- Tuple containing the final configurations and the total throughput. Additionally,
                the solver can return a list of the pricing objective values for each iteration.
                It can be useful to check if the solver has converged.
      :rtype: :class:`tuple[dict`, :class:`float]` or :class:`tuple[dict`, :class:`float`, :class:`list[float]]`



.. py:function:: positions_to_path_loss(pos, walls)

   Calculates the path loss for all nodes based on their positions and the wall positions.
   Channel is modeled using the TGax path loss model.

   :param pos: Two dimensional array of node positions. Each row corresponds to X and Y coordinates of a node.
   :type pos: :class:`array_like`
   :param walls: Adjacency matrix describing walls between nodes (1 if there is a wall, 0 otherwise).
   :type walls: :class:`array_like`

   :returns: Two-dimensional array of path losses (dB) between all nodes.
   :rtype: :class:`NDArray`


